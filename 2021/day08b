#!/usr/bin/awk -f
# works on OpenBSD awk, GNU awk and any implementation with bit-operations

function or7(a, b, c, d, e, f, g) {
	return or(a, or(b, or(c, or(d, or(e, or(f, g))))))
}

function encode(s,    i, n, r) {
	n = length(s)
	for (i = 1; i <= n; i++)
		r = or(r, bit[substr(s, i, 1)])
	return r
}

function decode(s,    i, n, r) {
	n = length(s)
	for (i = 1; i <= n; i++)
		r = or(r, corr[bit[substr(s, i, 1)]])
	return num[r]
}

BEGIN {
	RS = " \\| |\n"
	bit["a"] = A = 1
	bit["b"] = B = 2
	bit["c"] = C = 4
	bit["d"] = D = 8
	bit["e"] = E = 16
	bit["f"] = F = 32
	bit["g"] = G = 64
	num[or7(    C,    F  )] = 1
	num[or7(A,  C,    F  )] = 7
	num[or7(  B,C,D,  F  )] = 4
	num[or7(A,  C,D,E,  G)] = 2
	num[or7(A,  C,D,  F,G)] = 3
	num[or7(A,B,  D,  F,G)] = 5
	num[or7(A,B,C,  E,F,G)] = 0
	num[or7(A,B,  D,E,F,G)] = 6
	num[or7(A,B,C,D,  F,G)] = 9
	num[or7(A,B,C,D,E,F,G)] = 8
}

(NR % 2) {
	delete segs
	delete lens
	for (i = 1; i <= NF; i++)
		segs[length($i), ++lens[length($i)]] = encode($i)

	abfg = and(segs[6, 1], and(segs[6, 2], segs[6, 3]))
	abd  = xor(segs[3, 1], segs[4, 1])
	adg  = and(segs[5, 1], and(segs[5, 2], segs[5, 3]))
	a    = xor(segs[3, 1], segs[2, 1])
	g    = and(adg, compl(abd))
	b    = and(abd, compl(adg))
	d    = and(abd, compl(or(a, b)))
	f    = xor(abfg, or(a, or(b, g)))
	c    = xor(segs[2, 1], f)
	e    = xor(segs[7, 1], or7(a, b, c, d, f, g))

	corr[a] = bit["a"]
	corr[b] = bit["b"]
	corr[c] = bit["c"]
	corr[d] = bit["d"]
	corr[e] = bit["e"]
	corr[f] = bit["f"]
	corr[g] = bit["g"]
}

!(NR % 2) {
	x = 0
	for (i = 1; i <= NF; i++)
		x = 10 * x + decode($i)
	n += x
}

END {
	print n
}
